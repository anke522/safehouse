<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>SafeHouse</title>
  <script src="/Build/Cesium/Cesium.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script src="https://code.jquery.com/ui/1.12.0/jquery-ui.min.js"></script>
  <style>
      @import url(/Build/Cesium/Widgets/widgets.css);
      html, body, #cesiumContainer {
          width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <script>
    var viewer = new Cesium.Viewer('cesiumContainer', {
      baseLayerPicker: true,
      imageryProvider: Cesium.createOpenStreetMapImageryProvider({
          url : 'https://stamen-tiles.a.ssl.fastly.net/toner-background/',
          credit : 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA.'
      })
    });

    var scene = viewer.scene;

    var devices = {};

    var lat = -82.4374762;
    var lon = 27.9561611;

    var center = Cesium.Cartesian3.fromDegrees(lat, lon, 0.0);
    var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
    var model = Cesium.Model.fromGltf({
        url : '/models/Global_SOFWERX.glb',
        modelMatrix : modelMatrix,
        scale : 1.0
    });
    model.colorBlendMode = Cesium.ColorBlendMode.HIGHLIGHT;
    model.colorBlendAmount = 0.5;
    scene.globe.depthTestAgainstTerrain = true;
    devices["safehouse"] = scene.primitives.add(model);
    var heading = Cesium.Math.toRadians(0.0);
    var pitch = Cesium.Math.toRadians(0.0);
    var range = 100.0;
    viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));

    function addArc(pointA,pointB){
      var earth = Cesium.Ellipsoid.WGS84;
      // start and end points on the surface of the earth
      //var startPoint = earth.cartographicToCartesian(Cesium.Cartographic.fromDegrees(pointA[0][0], pointA[0][1], 0.0));
      //var endPoint = earth.cartographicToCartesian(Cesium.Cartographic.fromDegrees(pointB[0][0], pointB[0][1], 0.0));
      var startPoint = earth.cartographicToCartesian(pointA);
      var endPoint = earth.cartographicToCartesian(pointB);
      console.log(`addArc pointA=${pointA} startPoint=${startPoint} pointB=${pointB} endPoint=${endPoint}`);
      // determine the midpoint (point will be inside the earth)
      var midpointCartesian = startPoint.add(endPoint).divideByScalar(2.0);
      // move the midpoint to the surface of the earth
      earth.scaleToGeodeticSurface(midpointCartesian);
      // add some altitude if you want (10m in this case)
      var midpointCartographic = earth.cartesianToCartographic(midpointCartesian);
      midpointCartographic.height = 10;
      midpointCartesian = earth.cartographicToCartesian(midpointCartographic);
      // create a hermite spline that goes through these three points
      var hermiteSpline = new Cesium.HermiteSpline( [
        {point: startPoint, time: 0.0},
        {point: midpointCartesian, time: 0.5},
        {point: endPoint, time: 1.0}
      ]);
      // create a 20 point polyline that follows the spline
      var polylinePoints = [];
      for(var i=0; i<20; ++i) {
        polylinePoints.push(hermiteSpline.evaluate(i/20));
      }
      var polylineCollection = new Cesium.PolylineCollection();
      var polyline = polylineCollection.add();
      polyline.setPositions(polylinePoints);
      var primitives = viewer.scene.getPrimitives();
      primitives.add(polylineCollection);
    }

    devices["doorCamera"] = viewer.entities.add({
      name : 'doorCamera',
      position: Cesium.Cartesian3.fromDegrees(lat, lon + 0.0000150, 2.6),
      box : {
        dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
        material : Cesium.Color.BLUE.withAlpha(0.5),
        outline : true,
	outlineWidth : 8,
        outlineColor : Cesium.Color.BLACK
      }
    })

/*
    devices.minicam = viewer.entities.add({
      name : 'miniCamera',
      position: Cesium.Cartesian3.fromDegrees(lat + 0.0000042, lon + 0.00008440, 0.5),
      box : {
        dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
        material : Cesium.Color.BLUE.withAlpha(0.5),
        outline : true,
	outlineWidth : 8,
        outlineColor : Cesium.Color.BLACK
      }
   });
*/

   var cartographicDoorLock = Cesium.Cartographic.fromDegrees(lat, lon + 0.0000180, 1.2);
   console.log(`cartographicDoorLock = ${cartographicDoorLock}`)
   var cartesian3DoorLock = Cesium.Cartesian3.fromDegrees(lat, lon + 0.0000180, 1.2);
   console.log(`cartesian3DoorLock = ${cartesian3DoorLock}`)
   devices["doorLock"] = viewer.entities.add({
     name : 'doorLock',
     position: cartesian3DoorLock,
     box : {
       dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
       material : Cesium.Color.BLUE.withAlpha(0.5),
       outline : true,
       outlineWidth : 8,
       outlineColor : Cesium.Color.BLACK
     }
   });

   devices["motionDetector"] = viewer.entities.add({
     name : 'motionDetector',
     position: Cesium.Cartesian3.fromDegrees(lat + 0.0000340, lon + 0.0000310, 1.2),
     box : {
       dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
       material : Cesium.Color.BLUE.withAlpha(0.5),
       outline : true,
       outlineWidth : 8,
       outlineColor : Cesium.Color.BLACK
     }
   });

/*
   var range3 = viewer.entities.add({
     name : 'range3',
     position: Cesium.Cartesian3.fromDegrees(lat + 0.0000290, lon + 0.00005590, 1.1),
     box : {
       dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
       material : Cesium.Color.BLUE.withAlpha(0.5),
       outline : true,
       outlineWidth : 8,
       outlineColor : Cesium.Color.BLACK
     }
   });
*/

   var cartographicAccessPoint = Cesium.Cartographic.fromDegrees(lat + 0.0000279, lon + 0.0000269, 2.0);
   console.log(`cartographicAccessPoint = ${cartographicAccessPoint}`)
   var cartesian3AccessPoint = Cesium.Cartesian3.fromDegrees(lat + 0.0000279, lon + 0.0000269, 2.0);
   console.log(`cartesian3AccessPoint = ${cartesian3AccessPoint}`)
   devices["accessPoint"] = viewer.entities.add({
     name : 'accessPoint',
     position: cartesian3AccessPoint,
     box : {
       dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
       material : Cesium.Color.BLUE.withAlpha(0.5),
       outline : true,
       outlineWidth : 8,
       outlineColor : Cesium.Color.BLACK
     }
   });

   /*addArc(cartographicAccessPoint, cartographicDoorLock);*/

   devices["lamp1"] = viewer.entities.add({
     name : 'lamp1',
     position: Cesium.Cartesian3.fromDegrees( lat + 0.0000298, lon + 0.0000269, 0.3),
     box : {
        dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
        material : Cesium.Color.BLUE.withAlpha(0.5),
        outline : true,
        outlineWidth : 8,
        outlineColor : Cesium.Color.BLACK
     }
   });

/*

   var blueRange1 = viewer.entities.add({
     name : 'blueRange1',
     position: Cesium.Cartesian3.fromDegrees( lat + 0.0000194, lon + 0.0000030, 1.1),
     box : {
        dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
        material : Cesium.Color.BLUE.withAlpha(0.5),
        outline : true,
        outlineWidth : 8,
        outlineColor : Cesium.Color.BLACK
     }
   });

   var Alexa = viewer.entities.add({
     name : 'alexa',
     position: Cesium.Cartesian3.fromDegrees(lat + 0.0000279, lon + 0.0000029, 0.7),
     box : {
       dimensions : new Cesium.Cartesian3(0.25, 0.25, 0.25),
       material : Cesium.Color.BLUE.withAlpha(0.5),
       outline : true,
       outlineWidth : 8,
       outlineColor : Cesium.Color.BLACK
     }
   });
*/

   var colorizeInterval

   /* Every 5s, ask the server for the color state for devices */
   var colorizePeriod = 5000

   /* Every 100ms, decreates the alpha value a little */
   var animationPeriod = 200

   var configs = {}

   function colorize() {
     $.get( "/state", function( data ) {
       if(data && data.state) {
         $.each(data.state, function( name, value ) {
           config = data.state[name]
           colorname = config["color"]
           alpha = config["alpha"]
           startalpha = config["alphaStart"]
           endalpha = config["alphaEnd"]
           config["alphaDelta"] = (startalpha - endalpha) / ( colorizePeriod / animationPeriod )
	   device = devices[name]
	   if(device) {
	     configs[name] = config
             if(device) {
               if(device.box) {
                 device.box.material = Cesium.Color[colorname].withAlpha(alpha)
               } else {
                 if(device.color) {
                   device.color = Cesium.Color[colorname].withAlpha(alpha)
		 } else {
                   console.log(`Cannot find device.box or device.color for ${name}`)
		 }
               }
             } else {
               console.log(`Cannot find device state for ${name}`)
             }
	   }
	 })
       }
     })
   }

   function animate() {
     $.each(configs, function( name, config ) {
       device = devices[name]
       oldalpha = config["alpha"]
       alphaDelta = config["alphaDelta"]
       newalpha = oldalpha - alphaDelta
       if(newalpha >= config["alphaEnd"]) {
         config["alpha"] = newalpha
         colorname = config["color"]
         console.log(`newalpha ${newalpha} alphaDelta ${alphaDelta}`)
         device.box.material = Cesium.Color[colorname].withAlpha(newalpha)
       }
     })
   }

   colorizeInterval = setInterval(colorize, colorizePeriod)

/*   animationInterval = setInterval(animate, animationPeriod) */

  </script>
</body>
</html>
